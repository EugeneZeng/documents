# 不要阻塞事件循环（或工作池） #
## 原文：《[Don't Block the Event Loop (or the Worker Pool)](https://nodejs.org/en/docs/guides/dont-block-the-event-loop/ "Don't Block the Event Loop (or the Worker Pool)")》 ##
### 你该阅读这篇文章吗？（Should you read this guide?） ###
如果你正在写一些比简单的命令行脚本更复杂的东西，阅读这篇文章应该会帮助你写出更加高效，更加安全的应用程序。<br />
这篇文章是用Node服务器的构思写的，但是这个概念也可以应用在复杂的Node应用程序上。考虑到操作系统的差异，这个文档是以Linux为中心的。
### TL; DR ###
Node.js在事件循环里执行Javascript代码（初始化和回调），和提供一个工作池来处理繁重的任务比如文件I/O。Node的可扩展性强，有时候还好于更重量级的实现例如Apache。秘诀就在与Node的可伸缩性是用了很少数量的线程来处理许多任务。如果Node可以使用更少的线程，那它就可以把系统时间和内存用在任务上，而非花更多的时间和空间在系统开销上（内存和上下文切换）。但是，因为Node只有少量的线程，所以你必须明智地使用它们构建你的应用程序。<br />
这里有个很好的经验法则来保持你的Node服务器快速运行：_在给定时间内，与每个客户相关的工作都是小的，Node就会很快。(Node is fast when the work associated with each client at any given time is "small")_<br />
这个应用在事件循环的回调和工作池的任务上。

### 为什么我应该避免阻塞事件循环和工作池? ###
Node用很少数量的线程来处理许多客户。在Node里面，有两种线程：事件循环（又称主池，主线程，事件线程等等），和在工作池里面的`k`工作池（又称线程池）。<br />
如果一个线程用了很长时间去执行一个回调（事件循环）或者一个任务（工作），我们就叫它“阻塞”。当一个线程阻塞了代表一个客户的工作流，它就不能够处理来自于其他任何客户的请求。这就提供了两种阻塞事件循环和工作流的动机：
1. 性能：如果你经常在两种线程中实现重量级的行为，你的服务器的吞吐量（请求数/秒）将受严重影响。
2. 安全：如果你的某个线程会因某种特定的输入而阻塞，那么恶意用户就可能会提交这种“恶意输入”，让你的线程阻塞，而不能服务于其他客户。这就是拒绝服务（[Denial of Service](https://en.wikipedia.org/wiki/Denial-of-service_attack "Denial of Service ")）攻击。

### 快速回顾下Node ###
Node使用事件驱动的架构：用事件循环密谋，用工作池来干重活。

什么样的代码会在事件循环中运行？<br />
当它们开始的时候，Node应用程序首先会完成一个初始化阶段，加载模块和为事件注册回调。Node应用程序然后就会进入事件循环。运行合适的回调来响应客户的请求。这些请求同步地运行，当它完成以后有可能会注册异步的请求来继续处理。这些异步请求的回调也将会在事件循环中运行。
